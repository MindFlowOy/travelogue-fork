// Generated by CoffeeScript 1.6.3
(function() {
  var Hapi, Passport, internals;

  Passport = require("passport");

  Hapi = null;

  internals = {};

  internals.defaults = {
    urls: {
      failureRedirect: "/login",
      successRedirect: "/"
    },
    excludePaths: []
  };

  exports.register = function(plugin, options, next) {
    var settings;
    internals.setHapi(plugin.hapi);
    settings = plugin.hapi.utils.applyToDefaults(internals.defaults, options);
    plugin.dependency("yar");
    plugin.api("settings", settings);
    plugin.api("passport", Passport);
    Passport.framework({
      initialize: internals.initialize,
      authenticate: internals.authenticate(settings)
    });
    plugin.ext("onPreAuth", [Passport.initialize(), internals.exclude(settings.excludePaths, Passport.session())], {
      after: "yar"
    });
    plugin.auth("passport", {
      implementation: new internals.Scheme(settings, plugin.hapi),
      defaultMode: settings.defaultMode
    });
    return next();
  };

  internals.exclude = function(paths, callback) {
    return function(request, next) {
      var complete, isExcludable;
      isExcludable = false;
      complete = function() {
        if (isExcludable) {
          return next();
        } else {
          return callback(request, next);
        }
      };
      paths.forEach(function(path) {
        if (request.url.path.indexOf(path) >= 0) {
          return isExcludable = true;
        }
      });
      return complete();
    };
  };

  internals.initialize = function() {
    return function(request, next) {
      var passport, passportSession;
      passport = this;
      request._passport = {};
      request._passport.instance = passport;
      passportSession = request.session;
      if (passportSession) {
        request._passport.session = request.session;
      } else {
        request.session = request.session || {};
        passportSession = {};
        request.session["_passport"] = passportSession;
        request._passport.session = passportSession;
      }
      if (request.session.hasOwnProperty("lazy")) {
        request.session.lazy(true);
      }
      request.session._isAuthenticated = function() {
        var property;
        property = "user";
        if (request._passport && request._passport.instance._userProperty) {
          property = request._passport.instance._userProperty;
        }
        if (request[property]) {
          return true;
        } else {
          return false;
        }
      };
      request.session._login = request.session._logIn = function(user, options, done) {
        var property, session;
        if (!request._passport) {
          throw new Error("passport.initialize() middleware not in use");
        }
        if (!done && typeof options === "function") {
          done = options;
          options = {};
        }
        options = options || {};
        property = request._passport.instance._userProperty || "user";
        session = request.session || null;
        request[property] = user;
        if (session && request._passport.instance.serializeUser) {
          return request._passport.instance.serializeUser(user, function(err, obj) {
            if (err) {
              request[property] = null;
              return done(err);
            }
            request._passport.session.user = obj;
            request.session.user = obj;
            return done();
          });
        } else {
          return done && done();
        }
      };
      request.session._logout = request.session._logOut = function() {
        var property;
        if (!request._passport) {
          throw new Error("passport.initialize() middleware not in use");
        }
        property = request._passport.instance._userProperty || "user";
        request[property] = null;
        return delete request._passport.session.user;
      };
      return next();
    };
  };

  internals.authenticate = function(settings) {
    return function(name, options, callback) {
      var authenticate, self;
      self = this;
      if (!callback && typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if (!Array.isArray(name)) {
        name = [name];
      }
      return authenticate = function(request, next) {
        var allFailed, attempt, failures, passport;
        passport = this;
        failures = [];
        if (!next) {
          next = function(err) {
            return request.reply.redirect((err ? options.failureRedirect || settings.failureRedirect || "/" : options.successRedirect || settings.successRedirect || "/"));
          };
        }
        allFailed = internals.allFailedFactory(request, failures, options, callback);
        attempt = internals.attemptFactory(passport, request, name, failures, allFailed, options, next, callback);
        return attempt(0, next);
      };
    };
  };

  internals.allFailedFactory = function(request, failures, options, callback) {
    var allFailed;
    return allFailed = function() {
      var challenge, challenges, failure, flash, i, l, msg, rchallenge, rstatus, status, statuses, type;
      if (callback) {
        if (failures.length === 1) {
          return callback(null, false, failures[0].challenge, failures[0].status);
        } else {
          challenges = failures.map(function(f) {
            return f.challenge;
          });
          statuses = failures.map(function(f) {
            return f.status;
          });
          return callback(null, false, challenges, statuses);
        }
      }
      failure = failures[0] || {};
      challenge = failure.challenge || {};
      if (options.failureFlash) {
        flash = options.failureFlash;
        if (typeof flash === "string") {
          flash = {
            type: "error",
            message: flash
          };
        }
        flash.type = flash.type || "error";
        type = flash.type || challenge.type || "error";
        msg = flash.message || challenge.message || challenge;
        if (typeof msg === "string") {
          request.session.flash(type, msg);
        }
      }
      if (options.failureMessage) {
        msg = options.failureMessage;
        if (typeof msg === "boolean") {
          msg = challenge.message || challenge;
        }
        if (typeof msg === "string") {
          request.session.messages = request.session.messages || [];
          request.session.messages.push(msg);
        }
      }
      if (options.failureRedirect) {
        return request.reply.redirect(options.failureRedirect);
      }
      rchallenge = [];
      rstatus = null;
      i = 0;
      l = failures.length;
      while (i < l) {
        failure = failures[i];
        challenge = failure.challenge || {};
        status = failure.status;
        if (typeof challenge === "number") {
          status = challenge;
          challenge = null;
        }
        rstatus = rstatus || status;
        if (typeof challenge === "string") {
          rchallenge.push(challenge);
        }
        ++i;
      }
      return request.reply(Hapi.error.unauthorized("Unauthorized", rchallenge || null));
    };
  };

  internals.attemptFactory = function(passport, request, name, failures, allFailed, options, next, callback) {
    var attempt;
    return attempt = function(i, cb) {
      var actions, delegate, layer, method, prototype, req, strategy;
      delegate = {};
      options.session = options.session || request.session;
      delegate.success = function(user, info) {
        var complete, flash, msg, type;
        if (request._synth.session) {
          Hapi.utils.applyToDefaults(request.session, request._synth.session);
        }
        if (callback) {
          return callback(null, user, info);
        }
        info = info || {};
        if (options.successFlash) {
          flash = options.successFlash;
          if (typeof flash === "string") {
            flash = {
              type: "success",
              message: flash
            };
          }
          flash.type = flash.type || "success";
          type = flash.type || info.type || "success";
          msg = flash.message || info.message || info;
          if (typeof msg === "string") {
            request.session.flash(type, msg);
          }
        }
        if (options.successMessage) {
          msg = options.successMessage;
          if (typeof msg === "boolean") {
            msg = info.message || info;
          }
          if (typeof msg === "string") {
            request.session.messages = request.session.messages || [];
            request.session.messages.push(msg);
          }
        }
        if (options.assignProperty) {
          request[options.assignProperty] = user;
        }
        complete = function() {
          var url;
          if (options.successReturnToOrRedirect) {
            url = options.successReturnToOrRedirect;
            if (request.session && request.session.returnTo) {
              url = request.session.returnTo;
              delete request.session.returnTo;
            }
            return request.reply.redirect(url);
          }
          if (options.successRedirect) {
            return request.reply.redirect(options.successRedirect);
          }
          return cb();
        };
        return request.session._logIn(user, options, function(err) {
          if (err) {
            return cb(err);
          }
          if (options.authInfo) {
            return passport.transformAuthInfo(info, internals.transformAuthInfoCallback(request, cb, complete));
          } else {
            return complete();
          }
        });
      };
      delegate.fail = function(challenge, status) {
        failures.push({
          challenge: challenge,
          status: status
        });
        return attempt(i + 1, cb);
      };
      delegate.pass = function() {
        if (request._synth.user) {
          request.user = request._synth.user;
          request.session.user = request.user;
        }
        return cb();
      };
      delegate.error = internals.delegateErrorFactory(cb);
      delegate.redirect = internals.delegateRedirectFactory(request);
      layer = name[i];
      if (!layer) {
        return allFailed();
      }
      prototype = passport._strategy(layer);
      if (!prototype) {
        return next(Hapi.error.internal("No strategy registered under the name:" + layer));
      }
      actions = internals.actionsFactory();
      strategy = Object.create(prototype);
      for (method in actions) {
        strategy[method] = actions[method].bind(delegate);
      }
      req = {};
      req.query = request.url.query;
      req.body = request.payload;
      req._passport = request._passport;
      req.session = request.session;
      request._synth = req;
      req.url = request.url;
      req.url.method = request.method.toUpperCase();
      req.url.url = request.url.href;
      return strategy.authenticate(req, options);
    };
  };

  internals.actionsFactory = function() {
    return {
      success: function(user, info) {
        return this.success.apply(this, arguments);
      },
      fail: function(challenge, status) {
        return this.fail.apply(this, arguments);
      },
      redirect: function(url, status) {
        return this.redirect.apply(this, arguments);
      },
      pass: function() {
        return this.pass.apply(this, arguments);
      },
      error: function(err) {
        return this.error.apply(this, arguments);
      }
    };
  };

  internals.transformAuthInfoCallback = function(request, cb, complete) {
    return function(err, tinfo) {
      if (err) {
        return cb(err);
      }
      request.authInfo = tinfo;
      return complete();
    };
  };

  internals.delegateErrorFactory = function(cb) {
    return function(err) {
      if (err) {
        err = Hapi.error.internal("Passport Error: " + err);
      }
      return cb(err);
    };
  };

  internals.delegateRedirectFactory = function(request) {
    return function(url, status) {
      return request.reply.redirect(url);
    };
  };

  internals.Scheme = function(options, hapi) {
    this.settings = options;
    this.hapi = hapi;
    return this;
  };

  internals.Scheme.prototype.authenticate = function(request, callback) {
    var errReply;
    if (request.session._isAuthenticated()) {
      return callback(null, {});
    }
    errReply = {
      err: "unauthenticated"
    };
    return callback(new this.hapi.response.Obj(errReply).code(401));
  };

  internals.setHapi = function(module) {
    return Hapi = Hapi || module;
  };

  if (process.env.NODE_ENV === "test") {
    exports.internals = internals;
  }

}).call(this);
